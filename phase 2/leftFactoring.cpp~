#include <bits/stdc++.h>
#include "grammarFileParser.h"
#include "../constants.h"
using namespace std;

class leftFactoring {
    grammarFileParser *gfp;

public:
    leftFactoring(grammarFileParser *gfp) {
        this->gfp = gfp;
    }

    const int MAXINT = 1000000000;

    // unordered_map<int, vector<int> > generate2PowN(int n) {
    //     unordered_map<int, vector<int> > levels;
    //     for (int i = 1; i < (1 << n); i++) {
    //         int cnt = 0;
    //         for (int j = 0; j < n; j++) {
    //             if (i & (1 << j)) {
    //                 cnt++;
    //             }
    //         }
    //         if (cnt == 0 || cnt == 1) {
    //             continue;
    //         }
    //         levels[cnt].push_back(i);
    //     }
    //
    //     return levels;
    // }
    //
    // pair<vector<string>, vector<int> > getCommonSubProduction(const vector<string> &productions, int i) {
    //     vector<string> commonSubProduction;
    //     vector<int> indices;
    //     for (int j = 0; j < productions.size(); j++) {
    //         if (i & (1 << j)) {
    //             commonSubProduction.push_back(productions[j]);
    //             indices.push_back(j);
    //         }
    //     }
    //     return {commonSubProduction, indices};
    // }
    //
    // vector<string> getCommonPrefix(vector<string> productions) {
    //     vector<string> commonPrefix;
    //     Trie trie = Trie();
    //     for (string production: productions) {
    //         vector<string> tokens = gfp->splitByDelimiter(production, ' ');
    //         trie.insert(tokens);
    //     }
    //     string prefix = trie.getCommonPrefixOfTrie();
    //     return commonPrefix;
    // }
    //
    // void leftFactor(string nonTerminal) {
    //     int n = gfp->grammar[nonTerminal].size();
    //     unordered_map<int, vector<int> > levels = generate2PowN(n);
    //     vector<string> productions = gfp->grammar[nonTerminal];
    //     for (int i = levels.size() - 1; i > 1; i--) {
    //         vector<int> levelValues = levels[i];
    //         for (int j: levelValues) {
    //             pair<vector<string>, vector<int> > commonSubProduction = getCommonSubProduction(productions, j);
    //             vector<string> commonPrefix = getCommonPrefix(commonSubProduction.first);
    //             if (commonPrefix.empty()) {
    //                 continue;
    //             }
    //             //if the
    //
    //         }
    //     }
    // }

    vector<string> getSuffixes(const vector<string> &productions, int common_prefix_length, int i,
                               int common_prefix_index) {
        vector<string> suffixes;
        for (int j = i; j <= common_prefix_index; j++) {
            suffixes.push_back(productions[j].substr(common_prefix_length));
        }
        return suffixes;
    }

    void leftFactor() {
        vector<string> newNonTerminals;
        for (string nonTerminal: gfp->nonTerminals) {
            newNonTerminals.push_back(nonTerminal);
            performLeftFactoring(nonTerminal, newNonTerminals);
        }
        gfp->nonTerminals = newNonTerminals;
    }

    void performLeftFactoring(string nonTerminal, vector<string> &newNonTerminals) {
        vector<string> productions = gfp->grammar[nonTerminal];
        string prime = "*";
        sort(productions.begin(), productions.end());
        vector<string> newProductions;
        for (int i = 0; i < productions.size(); i++) {
            vector<string> production = gfp->splitByDelimiter(productions[i], ' ');
            int commonPrefixLength = MAXINT; // the common prefix elements  in the array of strings
            int commonPrefixIndex = -1;
            for (int j = i + 1; j < productions.size(); j++) {
                int k = 0;
                vector<string> nextProduction = gfp->splitByDelimiter(productions[j], ' ');
                while (k < production.size() && k < nextProduction.size() && production[k] == nextProduction[k]) {
                    k++;
                }
                if (k == 0) {
                    break;
                }
                commonPrefixLength = min(commonPrefixLength, k);
                commonPrefixIndex = j;
            }
            if (commonPrefixLength == MAXINT) {
                newProductions.push_back(productions[i]);
                continue;
            }
            vector commonPrefix(production.begin(), production.begin() + commonPrefixLength);
            string concatenatedCommonPrefix = "";
            for (int k = 0; k < commonPrefix.size() - 1; k++) {
                concatenatedCommonPrefix += commonPrefix[k] + " ";
            }
            concatenatedCommonPrefix += commonPrefix[commonPrefix.size() - 1];
            string newNonTerminal = nonTerminal + prime;
            prime += "*";
            vector<string> suffixes = getSuffixes(productions, concatenatedCommonPrefix.size(), i, commonPrefixIndex);
            newProductions.push_back(concatenatedCommonPrefix + " " + newNonTerminal);
            vector<string> productionsPrime;
            for (string suffix: suffixes) {
                if (suffix.empty()) {
                    productionsPrime.push_back(string(1, EPSILON));
                } else {
                    productionsPrime.push_back(suffix);
                }
            }
            gfp->grammar[newNonTerminal] = productionsPrime;
            newNonTerminals.push_back(newNonTerminal);
            i = commonPrefixIndex;
        }
        gfp->grammar[nonTerminal] = newProductions;
    }

};
